#!/bin/bash

# database
DB_USER=root
DB_PASS="xxx"
DB_NAME="linker"

OS_LIBS="/var/lib"
FIRM_DIR="$OS_LIBS/linker_firmware"
SERVICE_DIR="/usr/local/bin"
dev_dir(){
  dev_dir_file=$OS_LIBS/SC_LINKER_DEV_DIR
  sudo touch $dev_dir_file
  content_dev_dir_file="$(sudo -- bash -c "cat $dev_dir_file")";
  if [ -f "$dev_dir_file" ] && [ ! -z "$content_dev_dir_file" ] && [ -d "$content_dev_dir_file" ]; then
    resp=$content_dev_dir_file
  else
    resp=$(find /home -type d -regextype posix-egrep -regex ".*/(workspace/sc_linker)")
    sudo -- bash -c "echo $resp > $dev_dir_file"
  fi
  echo $resp
}
# DEV_DIR="$HOME/workspace/sc_linker"


declare -a files_to_zip=(
  "Dockerfile"
  "docker-compose.yml"
  "current_version"
  "shell_server.js"
)

declare -a files_to_copy_from_dev_dir=(
  "docker-compose.yml"
  "Dockerfile"
)

repo_docker_image=denoww/linker #:linux

# architecture=$(uname -m)
# if [[ $architecture =~ 64 ]]; then
  ## x86_64
  # raspberry=false
# elif [[ $architecture =~ armv ]]; then
  ## armv7 - raspberry
  # raspberry=true
# fi


# functions
update_service() {
  sudo wget -O $SERVICE_DIR/_linker_service https://raw.githubusercontent.com/denoww/linker_firmware/master/linker_service;
  download_success=$?
  echo "downloading new linker_service"
  if [[ $download_success -eq 0 ]]; then
    # sucesso ao baixar
    sudo rm -f $SERVICE_DIR/linker_service
    sudo mv $SERVICE_DIR/_linker_service $SERVICE_DIR/linker_service
    sudo chmod 777 $SERVICE_DIR/linker_service;
    # sudo chmod +x $SERVICE_DIR/linker_service;
  else
    # erro ao baixar
    sudo rm -f $SERVICE_DIR/_linker_service
    echo "Erro ao baixar linker_service"
  fi
}
last_version() {
  echo $(curl 'https://api.github.com/repos/denoww/linker_firmware/tags' | awk '/name/ {gsub("\"|,", "", $2); print $2;exit;}')
}
current_version() {
  echo $(sudo -- bash -c "cat $FIRM_DIR/current_version")
}
download_firmware() {
  sudo mkdir -p $FIRM_DIR

  echo "Baixando zip"
  sudo wget -O $FIRM_DIR/_linker.tar.xz https://raw.githubusercontent.com/denoww/linker_firmware/master/linker.tar.xz;
  download_success=$?
  if [[ $download_success -eq 0 ]]; then
    sudo rm -f $FIRM_DIR/linker.tar.xz
    sudo mv $FIRM_DIR/_linker.tar.xz $FIRM_DIR/linker.tar.xz

    # apagando arquivos antigos
    for item in "${files_to_zip[@]}"; do
      echo "removendo $item"
      sudo rm -f $FIRM_DIR/$item;
    done

    echo "unzipping"
    sleep 1
    sudo tar -C $FIRM_DIR -xf $FIRM_DIR/linker.tar.xz

    # saveCurrentVersion
    pull_images_docker
  else
    # erro ao baixar
    sudo rm -f $FIRM_DIR/_linker.tar.xz
    echo "Erro ao baixar _linker.tar.xz"
  fi
}
close_ports(){
  ports=(
    3002
    3003
  )
  for port in "${ports[@]}"; do
    process=$(sudo lsof -t -i:$port)
    if ! [ -z "$process" ]; then
      sudo kill -9 $process
    fi
  done
}
stop_linker(){
  sudo docker stop linker
  sudo docker rm linker
}
stop(){
  cd $FIRM_DIR

  stop_linker
  stop_shell_server
  close_ports
}
start_shell_server(){
  sudo -- bash -c "export NODE_PATH=$(npm root --quiet -g); sudo pm2 start $FIRM_DIR/shell_server.js --name shell_server"
}
stop_shell_server(){
  sudo pm2 delete shell_server
}
restart_shell_server(){
  sudo pm2 restart shell_server
}
restart_prod(){
  stop_linker
  start_container_prod
  restart_shell_server
}
restart_dev(){
  stop_linker
  start_container_dev
  restart_shell_server
}

check_firmware_downloaded(){
  for item in "${files_to_zip[@]}"; do
    item_path=$FIRM_DIR/$item
    # echo "checando existencia de $item_path"
    if ! [ -f "$item_path" ]; then
      install_shell_server
      download_firmware
    fi
  done
}
start_prod(){
  stop
  check_firmware_downloaded
  start_container_prod
  start_shell_server
  help_start
  echo ==== Para ver os logs faça =======
  echo "   \$ linker_service logs"
}
start_dev(){
  stop
  check_firmware_downloaded
  start_container_dev
  start_shell_server
  help_start
  logs_dev
}

build_and_push_docker_images(){
  # build em amd64 e
  sudo docker buildx build --platform linux/amd64,linux/arm $(dev_dir) --push --tag denoww/linker:latest
  echo "pushed docker images..."

  # sudo docker-compose -f $FIRM_DIR/docker-compose.yml push
  # sudo docker manifest create denoww/linker:latest denoww/linker:linux
  # sudo nano /root/.docker/config.json
  # sudo docker manifest push denoww/linker # :latest
  # sudo docker push $repo_docker_image
}
pull_images_docker(){
  # sudo docker-compose -f $FIRM_DIR/docker-compose.yml pull
  sudo docker pull $repo_docker_image
}
start_container_prod(){
  sudo docker-compose -f $FIRM_DIR/docker-compose.yml up --force-recreate -d
}
start_container_dev(){
  sudo docker-compose -f $(dev_dir)/docker-compose.yml up --force-recreate -d
}
help_start(){
  echo
  echo
  echo ==== shell server ========
  echo "   http://localhost:3003"
  echo ==== linker server ========
  echo "   http://localhost:3002"
}

need_update() {
  last=$(last_version)
  current=$(current_version)
  if [ "$last" == "$current" ]; then
    echo false
  else
    echo true
  fi
}
install_shell_server(){
  sudo npm install -g express
  sudo npm link express
  sudo npm install -g child_process
  sudo npm link child_process
}
install_compilador_multi_arquitetura(){
  echo "============================================================================================="
  echo "  Instale buildx"
  echo "    faça com sudo su"
  echo "      https://github.com/docker/buildx/blob/master/README.md#installing"
  echo "============================================================================================="
  echo "  Instale o emulador QEMU (compila em outras arquiteturas: arm e amd64)"
  echo "    Para instalar"
  echo "      $ docker run --privileged --rm docker/binfmt:a7996909642ee92942dcd6cff44b9b95f08dad64"
  echo "============================================================================================="
}
install_mariadb(){
  # mariadb
  sudo apt-get install -y mariadb-server

  # Caso já existe uma senha e saiba ela tente
  # sudo mysqladmin -u $DB_USER password $DB_PASS -pMINHASENHAATUAL

  sudo mysqladmin -u $DB_USER password $DB_PASS
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "UPDATE mysql.user SET Password=PASSWORD('$DB_PASS') WHERE User='$DB_USER'"
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "DELETE FROM mysql.user WHERE User='$DB_USER' AND Host NOT IN ('localhost', '127.0.0.1', '::1')"
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "DELETE FROM mysql.user WHERE User=''"
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "DELETE FROM mysql.db WHERE Db='test' OR Db='test\_%'"
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "FLUSH PRIVILEGES"
  sudo mysql -u $DB_USER -p"$DB_PASS" -e "CREATE DATABASE $DB_NAME"

  # TESTE A SENHA NOVA
  # sudo mysql -u $DB_USER -p
}
# install_mysql(){
#   # mysql
#   sudo apt-get install -y mysql-server
#   # sudo systemctl unmask mysql.service
#   # sudo systemctl status mysql
#   # sudo systemctl start mysql

#   DB_USER=root
#   DB_PASS='xxx'
#   DB_NAME="linker"

#   # Caso já existe uma senha e saiba ela tente
#   # sudo mysql -pMINHASENHA -u $DB_USER -e "ALTER USER '$DB_USER'@'localhost' IDENTIFIED WITH mysql_native_password BY '$DB_PASS';"

#   # sudo mysqladmin -u $DB_USER password $DB_PASS
#   sudo mysql -u $DB_USER -e "ALTER USER '$DB_USER'@'localhost' IDENTIFIED WITH mysql_native_password BY '$DB_PASS';"
#   sudo mysql -u $DB_USER -e "DELETE FROM mysql.user WHERE User='$DB_USER' AND Host NOT IN ('localhost', '127.0.0.1', '::1')"
#   sudo mysql -u $DB_USER -e "DELETE FROM mysql.user WHERE User=''"
#   sudo mysql -u $DB_USER -e "DELETE FROM mysql.db WHERE Db='test' OR Db='test\_%'"
#   sudo mysql -u $DB_USER -e "FLUSH PRIVILEGES"
#   sudo mysql -u $DB_USER -e "CREATE DATABASE $DB_NAME"

#   # TESTE A SENHA NOVA
#   # sudo mysql -u $DB_USER -p
# }


install_node(){
  curl -sL https://deb.nodesource.com/setup_13.x | sudo -E bash -
  sudo apt-get install -y nodejs
}
install_docker(){
  # docker
  wget -O - https://get.docker.com/ | bash

  # docker-compose
  sudo pip3 install docker-compose

}
install_pm2(){
  # pm2
  wget -qO- https://getpm2.com/install.sh | bash;
  # log rotate
  sudo pm2 install pm2-logrotate;
  sudo pm2 set pm2-logrotate:max_size 1G;
}
install_nmap(){
  sudo apt-get --yes install nmap;
}
ask_install(){
  msg=$1
  time=$2
  if [ -z "$time" ]; then
    read -p "$msg (Y/n) " -n 1 -r
  else
    read -t $time -p "$msg (Y/n) " -n 1 -r
  fi
  ( [[ $REPLY =~ ^[Yy]$ ]] || [ -z "$REPLY" ] ) && install=true || install=false
  echo $install
}
install_dev_npm_packages(){
  sudo npm i nodemon -g
  sudo npm i coffee-script -g
  sudo npm i node-inspect -g
}
install_dev_dependents(){
  ######### DANGER ###############################################
  # criar aqui no shellscript
  # install_dev_npm_packages etc
  ######### DANGER ###############################################
  declare -a to_install=(
    "dev_npm_packages"
  )
  install_items $to_install

}
install_dependents() {
  ######### DANGER ###############################################
  # criar aqui no shellscript
  # install_mariadb, install_node, install_shell_server etc
  ######### DANGER ###############################################
  declare -a to_install=(
    "mariadb"
    "node"
    "shell_server"
    "nmap"
    "pm2"
    "docker"
  )
  install_items $to_install
}
install_items(){
  sudo echo
  to_install=$1

  for item in "${to_install[@]}"; do
    resp_install="install_$item"
    eval $resp_install=$(ask_install "Instalar $item?", 10 )
    echo
  done

  for item in "${to_install[@]}"; do
    install_item="install_$item"
    resp_install="${!install_item}"
    if [ "$resp_install" == true ]; then
      eval $install_item
    fi
  done
}
_can_release(){
  if [ -z "$repo_docker_image" ]; then
    echo "Erro"
    echo "  variável repo_docker_image não foi definida no início desse script (possivelmente a arquitetura do processador não foi mapeada no início desse script)"
    exit
  fi
  git_user_name=$(git config user.name)
  git_user_email=$(git config user.email)
  if [ -z "$git_user_name" ]; then
    echo Erro
    echo "  configure seu git"
    echo "    \$ git config user.name \"Juliano Almeida\""
    exit
  fi
  if [ -z "$git_user_email" ]; then
    echo Erro
    echo "  configure seu git"
    echo "    \$ git config user.email \"juju@almeida.com\""
    exit
  fi
}
garantir_git_configurado(){
  git_user_email=$(git config user.email)
  if [ -z "$git_user_email" ]; then
    config_git_user
  fi
}
install_sc_linker(){
  garantir_git_configurado
  install_dependents
  install_dev_dependents
  clone_sc_linker
  cp .env_DEVELOPMENT_sample.coffee .env_DEVELOPMENT.coffee
  cp .env_PRODUCTION_sample.coffee .env_PRODUCTION.coffee
  npm install
  npm run start_dev
  echo
  echo SE DESEJA FAZER RELEASES SERÁ NECESSÁRIO INSTALAR O BUILDX
  install_compilador_multi_arquitetura
}
git_clone_linker_firmware() {
  garantir_git_configurado
  sudo rm -rf $FIRM_DIR
  # create_dir_firmware
  echo "Clonning repo to ${FIRM_DIR}..."
  git clone git@github.com:denoww/linker_firmware.git $HOME/linker_firmware
  sudo mv $HOME/linker_firmware $OS_LIBS
}
_ensure_firm_repo_updated() {
  # sudo chown $USER $OS_LIBS
  echo "Garantindo repositorio $FIRM_DIR atualizado..."
  if [ -d "$FIRM_DIR" ]; then
    if ! [ -d "$FIRM_DIR/.git" ]; then
      git_clone_linker_firmware
    else
      echo "git pull on ${FIRM_DIR}..."
      git -C $FIRM_DIR pull origin master
    fi
  else
    git_clone_linker_firmware
  fi
}
_can_build() {
  if ! [ -d "$(dev_dir)" ]; then
    # Take action if $DIR exists. #
    echo "Erro"
    echo "  Não existe pasta $(dev_dir) "
    echo "  clone o denoww/sc_linker para $(dev_dir)"
    exit
  fi
}
build(){
  sudo echo "Iniciando..."
  _can_build
  _ensure_firm_repo_updated


  # cd
  echo "Garantindo repositorio $(dev_dir) atualizado..."
  git -C $(dev_dir) pull origin master

  sudo docker build --tag $repo_docker_image $(dev_dir)

  # copy some files
  for item in "${files_to_copy_from_dev_dir[@]}"; do
    sudo rm -f $FIRM_DIR/$item
    sudo cp $(dev_dir)/$item $FIRM_DIR/$item
  done

  # comenta o volume - .:/src/
  # esse volume serve para podermos debugar docker em development (não precisar fazer build toda hora)
  sed -e '/- .:\/src\// s/^#*/#/' -i $FIRM_DIR/docker-compose.yml

  # start em start_docker_production invés de start_docker_devepoment
  sed -i 's/start_docker_dev/start_docker_prod/g' $FIRM_DIR/docker-compose.yml

  echo "installer finished!"

  # echo "converting js to coffee"
  # sudo find -name "*.coffee" -not -path "./app/assets/*" -exec coffee --compile {} \;

  # echo "compiling app"
  # sudo rm -f $FIRM_DIR/$linker_file
  # if [ $raspberry == true ]; then
  #   # Pegue a lista de nodes disponiveis aqui
  #   # https://github.com/zeit/pkg-fetch/releases
  #   pkg -t node12.2-linux-armv7 . --output $FIRM_DIR/$linker_file
  # else
  #   # Pegue a lista de nodes disponiveis aqui
  #   # https://github.com/zeit/pkg-fetch/releases
  #   pkg -t node12.2-linux-x64 . --output $FIRM_DIR/$linker_file
  # fi

  # echo "copying native libs"
  # sudo rm -f $FIRM_DIR/node_sqlite3.node
  # sudo find . -type f -name "node_sqlite3.node" -exec cp -n {} $FIRM_DIR/ \;

  # echo "remove js from cofee"
  # sudo find -name "*.js" -type f -not -path "./node_modules/*" -not -path "./node_modules/*" -not -path "./app/assets/*" -exec rm -rf {} \;
}
release(){
  sudo docker login
  cd $FIRM_DIR

  _can_release
  _ensure_firm_repo_updated
  echo "releasing..."

  build_and_push_docker_images

  # incrementando versão
  old_version=$(last_version)
  new_version=$(echo "$old_version" | tr -dc '0-9')
  new_version="$(($new_version + 1))"

  # atualizando .current_version
  echo Criando current_version
  sudo -- bash -c "echo $new_version > $FIRM_DIR/current_version"

  echo "removendo zip antigo..."
  sudo rm -f $FIRM_DIR/linker.tar.xz
  echo "zipping..."
  # tar -C $FIRM_DIR -cvf - docker-compose.yml Dockerfile current_version | xz -5 -c - > $FIRM_DIR/linker.tar.xz
  tar -C $FIRM_DIR -cvf - "${files_to_zip[@]}" | xz -5 -c - > $FIRM_DIR/linker.tar.xz

  git -C $FIRM_DIR add .

  echo "Push master"
  git -C $FIRM_DIR commit -m "Nova Versão $new_version"
  git -C $FIRM_DIR push origin master

  echo "Apagando todas tags antigas"
  git -C $FIRM_DIR fetch
  git push origin --delete $(git tag -l) # remote
  git -C $FIRM_DIR tag -l | xargs git tag -d # local

  echo "Criando novas tags $new_version"
  git -C $FIRM_DIR tag $new_version # local
  git -C $FIRM_DIR push origin $new_version # remote

  echo "Release da nova versão"
  echo "  $new_version"
}
logs(){
  docker logs -f linker
}
logs_dev(){
  echo
  echo
  logs
}
update_firmware(){
  need=$(need_update)
  if $need == true; then
    echo "Updating..."
    download_firmware
    restart_prod
  else
    echo "Já está na última versão"
  fi
}
install_firmware(){
  update_service
  install_dependents
  download_firmware
  echo "Agora faça"
  echo "  $ linker_service start_prod"
  echo "    Obs: Caso os 2 servidores não ligarem reinicie o computar e tente denovo $ linker_service start_prod"
}
# build_prod_and_release(){
#   _can_release
#   build
#   release
#   start_prod
# }
build_prod_and_start(){
  build
  start_prod
}
build_dev_and_start(){
  build
  start_dev
}
recreate_database(){
 sudo mysql -u $DB_USER -p"$DB_PASS" -e "DROP DATABASE $DB_NAME"
 sudo mysql -u $DB_USER -p"$DB_PASS" -e "CREATE DATABASE $DB_NAME"
}
db_console(){
  mysql -u $DB_USER -p"$DB_PASS" $DB_NAME
}
reset_data(){
  stop
  echo "Limpando volumes do docker"
  sudo docker volume rm sc_linker_linker_data
  sudo docker volume rm linker_firmware_linker_data
  recreate_database
}
reset_data_prod(){
  reset_data
  start_prod
}
reset_data_dev(){
  reset_data
  start_dev
}
clone_sc_linker(){
  mkdir ~/workspace
  cd workspace
  git clone git@github.com:denoww/sc_linker.git
  cd sc_linker
}
config_git_user(){
  echo '--- Configurando Git'
  echo ''

  sudo apt install -y xclip
  echo ''

  echo '-- Configurando Nome e email do git'
  read -p "Digite seu nome: " git_name
  git config --global user.name "$git_name"
  read -p "Digite seu email: " git_email
  git config --global user.email "$git_email"
  echo ''

  echo '-- Configurando SSH key git'
  ssh-keygen -t rsa -b 4096 -C "$git_email"
  eval "$(ssh-agent -s)"
  ssh-add ~/.ssh/id_rsa
  xclip -sel clip < ~/.ssh/id_rsa.pub
  echo ''

  echo '-- Código gerado e copiado, adicione com CTRL+V sua ssh key no seu github'
  sh -c 'chromium-browser https://github.com/settings/keys'
  read -p 'Digite [ENTER] para continuar caso já tenha adicionado '
  echo ''

  echo '-- Configurando para não pedir senha'
  ssh -T git@github.com
  echo ''

  echo '-- Configurando Atalhos'
  echo ''
  echo '- checkout => co'
  git config --global alias.co checkout
  echo '- branch => br'
  git config --global alias.br branch
  echo '- commit => ci'
  git config --global alias.ci commit
  echo '- status => st'
  git config --global alias.st status
  echo ''

  echo ''

  echo '--- Rodando SoftWare Update'
  echo ''
  sudo apt update
  echo ''
}

help(){
  echo "Production Docker"
  echo "  linker_service start_prod"
  echo "  linker_service restart_prod"
  echo "  linker_service logs"
  echo "  linker_service stop"
  echo "  linker_service build_prod_and_start"

  echo
  echo "Deploy"
  echo "  linker_service release"
  # echo "  linker_service build_prod_and_release"

  echo
  echo "Development Docker"
  echo "  linker_service build_dev_and_start"
  echo "  linker_service start_dev"
  echo "  linker_service restart_dev"
  echo "  linker_service stop"

  echo
  echo "Firmware: Updates e Install"
  echo "  linker_service install_firmware"
  echo "  linker_service update_firmware"
  echo "  linker_service update_service"

  echo
  echo "Shell server"
  echo "  linker_service install_shell_server"
  echo "  linker_service start_shell_server"
  echo "  linker_service restart_shell_server"
  echo "  linker_service logs_shell_server"

  echo
  echo "Esqueceu senha"
  echo "  linker_service reset_data_prod"
  echo "  linker_service reset_data_dev"

  echo
  echo "Setar data hora"
  echo "  linker_service set_timezone America/Sao_Paulo"
  echo "  linker_service set_date"

  echo
  echo "Versao"
  echo "  linker_service current_version"
  echo "  linker_service last_version"
  echo "  linker_service need_update"

  echo
  echo "Config DEV Enviroment"
  echo "  linker_service install_sc_linker"
  echo "  linker_service git_clone_linker_firmware"
  echo "  linker_service config_git_user"
  echo "  linker_service install_dependents"
  echo "  linker_service install_dev_dependents"
  echo "  linker_service install_compilador_multi_arquitetura"
  echo "  linker_service db_console"




  echo
}

###################################################
case $1 in
install_firmware)
  install_firmware
  ;;
update_firmware)
  update_firmware
  ;;
start_dev)
  start_dev
  ;;
build_dev_and_start)
  build_dev_and_start
  ;;
logs_shell_server)
  sudo pm2 logs shell_server
  ;;
install_shell_server)
  install_shell_server
  ;;
start_shell_server)
  start_shell_server
  ;;
restart_shell_server)
  restart_shell_server
  ;;
build_prod_and_start)
  build_prod_and_start
  ;;
# build_prod_and_release)
#   build_prod_and_release
#   ;;
db_console)
  db_console
  ;;
release)
  sudo echo "Releasing..."
  release
  ;;
update_service)
  echo "update_service"
  # rm -f $FIRM_DIR/update_service
  update_service
  ;;
start_prod)
  echo "Starting"
  start_prod
  ;;
stop)
  echo "Stoping..."
  stop
  ;;
restart_prod)
  echo "Restarting..."
  restart_prod
  ;;
restart_dev)
  echo "Restarting..."
  restart_dev
  ;;
need_update)
  # echo "Restarting..."
  need_update
  ;;
current_version)
  current_version
  ;;
last_version)
  last_version
  ;;
reset_data_prod)
  reset_data_prod
  ;;
reset_data_dev)
  reset_data_dev
  ;;
set_timezone)
  sudo sudo timedatectl set-timezone $2
  echo $2
  ;;
set_date)
  sudo date --set $2
  echo $2
  ;;
install_sc_linker)
  install_sc_linker
  ;;
git_clone_linker_firmware)
  git_clone_linker_firmware
  ;;
install_compilador_multi_arquitetura)
  install_compilador_multi_arquitetura
  ;;
install_dev_dependents)
  install_dev_dependents
  ;;
install_dependents)
  install_dependents
  ;;
config_git_user)
  config_git_user
  ;;
get_date)
  sudo date
  ;;
help)
  help
  ;;
-h)
  help
  ;;
logs)
  logs
  ;;
*)
  echo "Erro: Aprenda a usar linker_service"
  echo
  help
  exit 1 # 1 é resposta de erro
  ;;
esac

# imprime defeitos caso não conseguir detectar arquitetura
# if [ -z "$linker_file" ]; then
#   echo ============================================
#   echo problema o detectar arquitetura 64 ou armv
#   echo "\$linker_file está vazio"
#   echo ============================================
# fi
